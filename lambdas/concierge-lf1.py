import boto3

sqs = boto3.resource('sqs')

def lambda_handler(event, context):
    """
    Accepts an event generated by AWS Lex V2.
    If it is a DialogCodeHook event, validates slots.
    If it is a FulfillmentCodeHook, posts a job to a queue.
    """
    if event["invocationSource"] == "DialogCodeHook":
        return validation_handler(event)
    else: # FulfillmentCodeHook and all other cases
        return fulfillment_handler(event)

    
def validation_handler(event):
    """
    Accepts an event generated by AWS Lex V2.
    Validates Lex slots for acceptable values.
    """
    
    # Priority order of slots: 
    # location
    # cuisine
    # party_size
    # dining_time
    # email
    
    # Initialize the state messages we'll return
    my_session_state = event['sessionState']
    my_session_state['dialogAction'] = { 'type': 'Delegate' }
    my_messages = []
    
    if my_session_state["intent"]["name"] != "DiningSuggestionsIntent":
        return { 'sessionState': my_session_state }
    
    resolved_slots = event["transcriptions"][0]["resolvedSlots"]
    
    allowed_locations = [
        "manhattan", 
        "nyc",
        "ny",
        "new york, ny",
        "new york, new york",
        "new york city, ny",
        "new york", 
        "new york city",
        "new york city, new york",
    ]
    
    allowed_cuisines = [
        "japanese",
        "italian",
        "greek",
        "chinese",
        "seafood",
        "sushi",
        "mexican",
        "thai",
        "vietnamese",
        "french",
        "vegan",
    ]
    
    allowed_emails = [
        "<ENTER>",
        "<ENTER>",
        "<ENTER>",
    ]
    
    # Check these in reverse priority order,
    # so the highest priority slot is checked last
    # and will be the one processed by Lex.
    if "email" in resolved_slots:
        email = resolved_slots["email"]["value"]["originalValue"]
        if email.lower() not in allowed_emails:
            my_session_state['intent']['slots']['email'] = None
            my_session_state['dialogAction'] = {
                'type': 'ElicitSlot',
                'slotToElicit': 'email',
            }
            my_messages = [
                {
                    "contentType": "PlainText",
                    "content": "I can only email these address: " + ', '.join(allowed_emails),
                },
                {
                    "contentType": "PlainText",
                    "content": "What's your email address?",
                }
            ]
    if "cuisine" in resolved_slots:
        cuisine = resolved_slots["cuisine"]["value"]["originalValue"]
        if cuisine.lower() not in allowed_cuisines:
            my_session_state['intent']['slots']['cuisine'] = None
            my_session_state['dialogAction'] = {
                'type': 'ElicitSlot',
                'slotToElicit': 'cuisine',
            }
            my_messages = [
                {
                    "contentType": "PlainText",
                    "content": "I only know these cuisines: " + ', '.join(allowed_cuisines),
                },
                {
                    "contentType": "PlainText",
                    "content": "What cuisine are you looking for?",
                }
            ]
    if "location" in resolved_slots:
        location = resolved_slots["location"]["value"]["originalValue"]
        if location.lower() not in allowed_locations:
            my_session_state['intent']['slots']['location'] = None
            my_session_state['dialogAction'] = {
                'type': 'ElicitSlot',
                'slotToElicit': 'location',
            }
            my_messages = [
                {
                    "contentType": "PlainText",
                    "content": "I only know restaurants in Manhattan.",
                },
                {
                    "contentType": "PlainText",
                    "content": "What city or area are you looking to dine in?",
                }
            ]

    # Return validation results to Lex
    return {
        "sessionState": my_session_state,
        "messages": my_messages,
    }
    
    
def fulfillment_handler(event):
    """
    Accepts an event generated by AWS Lex V2.
    Posts to an AWS SQS queue.
    """

    # Initialize the state we'll return
    my_session_state = event['sessionState']
    my_session_state['intent']['state'] = 'Failed'
    my_session_state['dialogAction'] = {
        'type': 'Close'
    }
    
    # Get and validate the slots
    interpretations = event['interpretations']
    interpretation = next(
        intent for intent in interpretations 
        if intent['intent']['name'] == 'DiningSuggestionsIntent'
    )
    intent = interpretation['intent']
    slots = intent['slots']
    
    if "cuisine" not in slots: return { 'sessionState': my_session_state }
    if "party_size" not in slots: return { 'sessionState': my_session_state }
    if "email" not in slots: return { 'sessionState': my_session_state }
    if "dining_time" not in slots: return { 'sessionState': my_session_state }
    if "location" not in slots: return { 'sessionState': my_session_state }
    if slots["cuisine"] is None: return { 'sessionState': my_session_state }
    if slots["party_size"] is None: return { 'sessionState': my_session_state }
    if slots["email"] is None: return { 'sessionState': my_session_state }
    if slots["dining_time"] is None: return { 'sessionState': my_session_state }
    if slots["location"] is None: return { 'sessionState': my_session_state }
    
    # Publish to SQS to send recommendations
    queue = sqs.get_queue_by_name(QueueName='concierge-q1')

    # Create a new message
    sqs_response = queue.send_message(
        MessageBody='abc',
        MessageAttributes={
            'cuisine': {
                'StringValue': slots["cuisine"]["value"]["interpretedValue"],
                'DataType': 'String'
            },
            'location': {
                'StringValue': slots["location"]["value"]["interpretedValue"],
                'DataType': 'String'
            },
            'party_size': {
                'StringValue': slots["party_size"]["value"]["interpretedValue"],
                'DataType': 'String'
            },
            'dining_time': {
                'StringValue': slots["dining_time"]["value"]["interpretedValue"],
                'DataType': 'String'
            },
            'email': {
                'StringValue': slots["email"]["value"]["interpretedValue"],
                'DataType': 'String'
            },
        }
    )
    
    # Update state for Lex response
    my_session_state['intent']['state'] = 'Fulfilled'
    
    # Return OK to Lex
    return {
        "sessionState": my_session_state,
    }
